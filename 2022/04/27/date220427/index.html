<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    阶段性学习笔记（一） |
    
    AreUhungry</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-date220427" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  阶段性学习笔记（一）
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/04/27/date220427/" class="article-date">
  <time datetime="2022-04-26T22:00:00.000Z" itemprop="datePublished">2022-04-27</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>本章重点：</p>
<blockquote>
<p>1.React18的优化<br>2.React.memo与React.PureComponent用法及异同<br>3.自己写了一个hook<br>4.一些tips，关于es6空值判断，数组合并，html空格表达<br>5.antd Input使用过程遇到的bug<br>6.一些没什么卵用的废话</p>
</blockquote>
<p>这段时间没有接触到什么新的技术栈，一直在优化重构项目，plume2+immutable写了一遍，发现ts+这俩会让状态的管理繁琐到爆炸。于是参阅了大量项目标品的写法，结合之前的项目，百思不得其解为什么标品中所有的数据都用store来储存，模块之间并没有繁重的层层嵌套或高阶组件，完全可以用props实现数据传递。费解….。</p>
<span id="more"></span>
<p>在被immutable的繁琐语法折磨到苦不堪言的时候，我又去看了之前项目用的immer.js，是的，我只有这个时候才想起immer的好…于是不禁吐槽，同样是防止数据被篡改，immer果然短小精悍。<br>介于我如此唾弃标品的“代码规范”遂果断抛弃plume2+immutable，改用类组件重构，然后我惊喜的发现…因为用immer.js太久，我已经忘了原生的setState要怎么修改对象中属性值，真行（咬牙切齿.jpg），我又去复习了一遍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//类组件更新状态-对象属性值</span><br><span class="line">function onChange(name,value)&#123;</span><br><span class="line">    const obj=Object.assign(&#123;&#125;,this.state.obj);</span><br><span class="line">    const obj[name]=value;</span><br><span class="line">    this.setState(&#123;this.state.obj:obj)</span><br><span class="line">&#125;</span><br><span class="line">//函数组件更新状态-对象属性值</span><br><span class="line">const onChange=(name,value)&#123;</span><br><span class="line">    setValue(&#123;...obj,[name]:value&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写一遍后又想起了函数式组件，hooks不是学了吗，那你倒是用起来啊！！！<br>写的过程中开始逐渐理解为什么react社区推崇函数式组件，对于简单数据的更新，hooks提供的钩子函数要比类组件实现同样的功能代码简洁很多。在一次次的重构过程中学到了很多新的知识点⬇</p>
<h3 id="React18的优化"><a href="#React18的优化" class="headerlink" title="React18的优化"></a>React18的优化</h3><h4 id="1-transition"><a href="#1-transition" class="headerlink" title="1.transition"></a>1.transition</h4><p><strong>参考文章：</strong><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7027995169211285512">「React18新特性」深入浅出用户体验大师—transition</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7038402899860258847">漫谈 React 系列(四): React18 自己的防抖节流 - useTransition</a><br><strong>前言：</strong><br>transition的出现是为了解决多个状态更新的优先级问题，业务场景中有一个很常见的例子，例如在搜索框中键入字值列表需要同步展示包含关键字的item，如果此时把这两个更新任务放在一起，当输入框连续输入值，把列表更新的任务放在输入框后面，就会造成页面异常卡顿。<br>上述问题通常我们的解决思路，一，防抖，在用户输入完成时更新状态再进行列表搜索，二，节流，在一定时间后更新状态，但是两者都会造成一定程度的性能降低<br><strong>startTransition：</strong><br>来划分任务的优先级优化用户体验。不是那么紧急的任务包裹在该函数里，上述实例中，列表的搜索更新就可以放在该函数中。<br><strong>useTransition：</strong><br>useTransition定义了一个函数钩子，包括startTransition和一个等待状态值isPending，如果我们需要获取到startTransition函数中提供的数据源才允许用户操作，就可以用isPending来判断组件是否要处于禁用状态，当然这只是一个很小的应用场景，具体更多的应用场景还需要在项目中不断实践总结</p>
<h4 id="2-Suspense"><a href="#2-Suspense" class="headerlink" title="2.Suspense"></a>2.Suspense</h4><p>描述：类似骨架屏的概念，将未准备好的组件用Suspense嵌套优先加载已经准备好的组件，是loading状态的“平价替换”<br>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;Loading/&gt;&#125;&gt;</span><br><span class="line">    &lt;MyComponent myData=&#123;myData&#125;/&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>

<h3 id="React-memo与React-PureComponent"><a href="#React-memo与React-PureComponent" class="headerlink" title="React.memo与React.PureComponent"></a>React.memo与React.PureComponent</h3><p><strong>前言：</strong><br>React.memo是在看React18特性时候了解的，PureComponent是项目中遇到的，去查阅资料了解了一下，都是react16推出的，因为实际项目中都是秉承着能用就行，极少去优化性能，所以对此方面的知识并不熟悉。汗颜。。。<br><strong>memo:</strong><br>memo定义了两个传入参数，第一个是需要优化的组件，第二个是与之相比较的组件。其原理是用Object.is进行浅比较。官方的解释是</p>
<blockquote>
<p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。<br>React.memo仅检查props更改。如果你封装的函数组件在其实现中React.memo有一个useState,useReducer或useContextHook ，它仍然会在状态或上下文发生变化时重新渲染。</p>
</blockquote>
<p><strong>React.PureComponent：</strong><br>相当于自带shouldComponentUpdate的Component类<br><strong>共同点：</strong><br>都是为减少不必要的组件更新渲染，提高性能<br><strong>不同点：</strong><br>类型，memo是函数，PureComponent是类<br>应用场景，memo用在函数组件中，PureComponent用在类组件中<br><strong>实例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//React.memoy</span><br><span class="line">function Child(&#123;seconds&#125;)&#123;</span><br><span class="line">    console.log(&#x27;I am rendering&#x27;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line">export default React.memo(Child);</span><br><span class="line"></span><br><span class="line">//React.PureComponent</span><br><span class="line">class Child extends React.PureComponent &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(&#x27;I am rendering&#x27;);</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;I am update every &#123;this.props.seconds&#125; seconds&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="自定义一个hook"><a href="#自定义一个hook" class="headerlink" title="自定义一个hook"></a>自定义一个hook</h3><p>写hook也有一段时间，一直在用封装好的hook没有自己写过，写项目过程中发现有很多重复的逻辑所以打算自己尝试写一个hook<br><strong>前言：</strong> 据react hooks约定，自定义hook需要遵守</p>
<blockquote>
<p>const […返回]=useXxx(参数一，参数二)</p>
</blockquote>
<p>其次我们要知道hooks的出现是为了提高代码的复用率，减少不必要的重复代码，所以抽取公共逻辑/组件就变成了我们在写一个自定义hooks中重要的一环。<br><strong>业务逻辑描述：</strong> 这是我在项目中遇到的一个需求，大致是要写n个内容不同的form，然后实现表单内容修改提交。<br><strong>需求分析：</strong> 根据上述需求，我们先明确什么是公共部分（作为useXxxx函数内部必要的嵌套部分），什么是需要差异化的值（作为参数传入函数内部）,什么是需要外部需要的值（作为返回）</p>
<p>根据这个思路我们可以将useXxxx写为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Form, Input, InputNumber, Button &#125; from &quot;antd&quot;;</span><br><span class="line"></span><br><span class="line">const useForm = (dataSource) =&gt; &#123;</span><br><span class="line">  const [node, setNode] = useState(dataSource);</span><br><span class="line">  const elements = node ? Object.entries(node) : [];</span><br><span class="line">  const children = (type) =&gt; &#123;</span><br><span class="line">    let view = null;</span><br><span class="line">    switch (typeof type) &#123;</span><br><span class="line">      case &quot;number&quot;:</span><br><span class="line">        view = &lt;InputNumber /&gt;;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        view = &lt;Input /&gt;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return view;</span><br><span class="line">  &#125;;</span><br><span class="line">  const onFinish = (values) =&gt; &#123;</span><br><span class="line">    setNode(values);</span><br><span class="line">  &#125;;</span><br><span class="line">  const view = (</span><br><span class="line">    &lt;Form onFinish=&#123;onFinish&#125; initialValues=&#123;dataSource&#125;&gt;</span><br><span class="line">      &#123;elements.map((item, key) =&gt; &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;Form.Item name=&#123;item[0]&#125; label=&#123;item[0]&#125;&gt;</span><br><span class="line">            &#123;children(item[1])&#125;</span><br><span class="line">          &lt;/Form.Item&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt;</span><br><span class="line">        保存</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Form&gt;</span><br><span class="line">  );</span><br><span class="line">  return [view, node];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用这个hook</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useForm &#125; from &quot;./useForm&quot;;</span><br><span class="line"></span><br><span class="line">export default function App()&#123;</span><br><span class="line">  const data = &#123; name: &quot;123&quot;, age: 0 &#125;;</span><br><span class="line">  const [view, res] = useForm(data);</span><br><span class="line">  console.log(&quot;res&quot;,res);</span><br><span class="line">  return &lt;div className=&quot;App&quot;&gt;&#123;view&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过代码部分我们可以看到该hook实现了以下功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    输入-数据源object --&gt; useForm --&gt; 输出-表单组件&amp;保存后的值</span><br></pre></td></tr></table></figure>
<p>ps：上面的例子只是在理想情况下的一种数据假设，在项目中，表单的子项可能会根据业务需求搭配各种组件，在这种情况下我们通过判断属性类型来定义FormItem中的组件就不太适用了，所以建议将输入的data类型搭配ts重组，以便于通用hook的实现</p>
<h3 id="其他tips"><a href="#其他tips" class="headerlink" title="其他tips"></a>其他tips</h3><h4 id="ES6空值合并运算符"><a href="#ES6空值合并运算符" class="headerlink" title="ES6空值合并运算符"></a>ES6空值合并运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(value !== null &amp;&amp; value !== undefined &amp;&amp; value !== &#x27;&#x27;)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">//可以写成</span><br><span class="line">if((value??&#x27;&#x27;) !== &#x27;&#x27;)&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const a = [1,2,3];</span><br><span class="line">const b = [1,5,6];</span><br><span class="line">const c = a.concat(b);//[1,2,3,1,5,6]</span><br><span class="line"></span><br><span class="line">const obj1 = &#123;</span><br><span class="line">  a:1,</span><br><span class="line">&#125;</span><br><span class="line">const obj2 = &#123;</span><br><span class="line">  b:1,</span><br><span class="line">&#125;</span><br><span class="line">const obj = Object.assign(&#123;&#125;, obj1, obj2);//&#123;a:1,b:1&#125;</span><br><span class="line">//扩展运算符加去重</span><br><span class="line">const a = [1,2,3];</span><br><span class="line">const b = [1,5,6];</span><br><span class="line">const c = [...new Set([...a,...b])];//[1,2,3,5,6]</span><br><span class="line"></span><br><span class="line">const obj1 = &#123;</span><br><span class="line">  a:1,</span><br><span class="line">&#125;</span><br><span class="line">const obj2 = &#123;</span><br><span class="line">  b:1,</span><br><span class="line">&#125;</span><br><span class="line">const obj = &#123;...obj1,...obj2&#125;;//&#123;a:1,b:1&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML中的空格表达"><a href="#HTML中的空格表达" class="headerlink" title="HTML中的空格表达"></a>HTML中的空格表达</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;字符：不断行的空白格，该空格占据的宽度受字体影响(一个字符宽度)。</span><br><span class="line">&amp;ensp;字符：相当全角状态键入半个“空格”键（半个汉字的宽度，一个字符宽度）。</span><br><span class="line">&amp;emsp;字符：相当全角状态键入“空格”键（1个汉字的宽度，两个字符宽度）。</span><br></pre></td></tr></table></figure>
<h3 id="一个bug"><a href="#一个bug" class="headerlink" title="一个bug"></a>一个bug</h3><h5 id="bug描述：antd-FormItem-Input控件中校验最大值最小值出错"><a href="#bug描述：antd-FormItem-Input控件中校验最大值最小值出错" class="headerlink" title="bug描述：antd FormItem Input控件中校验最大值最小值出错"></a>bug描述：antd FormItem Input控件中校验最大值最小值出错</h5><h5 id="原因：Input输出的value类型是字符串，如果在rule里约定校验类型为number，接受到value为字符串就会一直触发错误信息"><a href="#原因：Input输出的value类型是字符串，如果在rule里约定校验类型为number，接受到value为字符串就会一直触发错误信息" class="headerlink" title="原因：Input输出的value类型是字符串，如果在rule里约定校验类型为number，接受到value为字符串就会一直触发错误信息"></a>原因：Input输出的value类型是字符串，如果在rule里约定校验类型为number，接受到value为字符串就会一直触发错误信息</h5><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormItem</span><br><span class="line">          rules=&#123;[</span><br><span class="line">            &#123;</span><br><span class="line">              required: true,</span><br><span class="line">              message: &#x27;字段必填&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              type: &#x27;number&#x27;,</span><br><span class="line">              min: 0,</span><br><span class="line">              max: 100,</span><br><span class="line">              message: &#x27;只允许输入0~100之间的数字&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ]&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;Input/&gt;</span><br><span class="line">        &lt;/FormItem&gt;</span><br></pre></td></tr></table></figure>
<h5 id="解决方案一-类型转换"><a href="#解决方案一-类型转换" class="headerlink" title="解决方案一:类型转换"></a>解决方案一:类型转换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormItem</span><br><span class="line">    rules=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            message: &#x27;字段必填&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            type: &#x27;number&#x27;,</span><br><span class="line">            min: 0,</span><br><span class="line">            max: 100,</span><br><span class="line">            message: &#x27;只允许输入0~100之间的数字&#x27;,</span><br><span class="line">            transform: (value: string) =&gt; Number(value),</span><br><span class="line">        &#125;,</span><br><span class="line">    ]&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;Input/&gt;</span><br><span class="line">&lt;/FormItem&gt;</span><br></pre></td></tr></table></figure>
<h5 id="解决方案二-改用InputNumber"><a href="#解决方案二-改用InputNumber" class="headerlink" title="解决方案二:改用InputNumber"></a>解决方案二:改用InputNumber</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormItem</span><br><span class="line">    rules=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            message: &#x27;字段必填&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            type: &#x27;number&#x27;,</span><br><span class="line">            min: 0,</span><br><span class="line">            max: 100,</span><br><span class="line">            message: &#x27;只允许输入0~100之间的数字&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ]&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;InputNumber/&gt;</span><br><span class="line">&lt;/FormItem&gt;</span><br></pre></td></tr></table></figure>
<p>造成困惑的根本原因还是对antd库的使用不熟。。。。</p>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>刚开始接触typescript的时候并没有觉得ts相比js有什么优势，因为平时工作中即使多人协作开发，也是自己写的方法自己用，所以开发者完全知道输入输出的数据类型，没有非约定类型不可的必要。而且总觉得弱类型里面声明类型是由简到繁的转变，于是typescript在项目中渐渐变成了anyscript…<br>直到最近看了一些react跟antd组件的源码，才发现原来像“天书”一样的源码都是基于ts编写的，以及在看源码的过程中被ts各种语法和工具类秀到头皮发麻，一个功能较为复杂的实现仅仅有2行ts代码，不禁感慨一句ts666。虽然源码还是有很多看不懂，不过在此过程中确实发现了ts的好处，类型的约定避免了框架或库在使用过程中一些不必要的错误</p>
<h3 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h3><p> 目前对于很多技术栈框架还是停留在会用但不懂原理的阶段，有时候为了提高开发的效率，只是一味的追求摄取短平快的知识点，但也造成了过目就忘，出了bug无法快速定位原因所在的一些毛病。在以后的开发过程中，会开始尝试侧重提高代码的健壮性，不再是简单的代码输出器或者需求翻译官，会更多的去挖掘数据业务逻辑与视图的耦合度。逐渐做到知其然知其所以然…从学习typescript开始…
 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/27/date220427/" data-id="cl2ytqfig000gaouk8moka8r7" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/05/09/date220506/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      阶段性学习笔记（二）
      
    </div>
  </a>
  
  
  <a href="/2022/03/31/date220331/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">事件冒泡，事件捕获</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>AreUhungry &copy; 2022</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/starfish.svg" alt="AreUhungry"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>