<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解决Input约束输入值为非负整数中遇到的一揽子问题</title>
    <url>/2021/05/11/date0511/</url>
    <content><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>​        项目中要求实现某模块的人数/天数输入值不能为负值</p>
<h3 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h3><p>​        1.无法键入0-9以外的字符</p>
<p>​        2.键入0-9以外的字符错误提示并无法提交</p>
<span id="more"></span>

<h3 id="解决过程："><a href="#解决过程：" class="headerlink" title="解决过程："></a>解决过程：</h3><p>​        第一次尝试：</p>
<p>​                Input type类型改为number ,min为0。</p>
<p>​                写完心满意足提交了代码，结果同事测试说上下键是没法子按到负值了，但是输入还是可以键入负数的。。。。。好吧</p>
<p>​        第二次尝试</p>
<p>​                用正则把输入的符号给替换掉。</p>
<p>​                结果同事提出意见说，Input里面用defaultValue做值的显示也就是当前的Input是一个非受控组件，用正则无法替换（既然这样，那为什么不用value呢，这里引申出另一个问题，defaultValue与value的使用场景，下一章里面详细谈论这个问题）</p>
<p>​        第三次尝试</p>
<p>​                改用AvField组件，在输入0-9以外的字符给出错误提示</p>
<p>​                改完在测试过程中发现，输入负号弹出来的报错信息不是预定的errorMessage，是this field is invaild。。。啊这什么鬼，后来在尝试过程中发现如果把type改为text就会正常输出预定的errorMessage。。。猜测可能是number限制的范围是所有整数（包括负号）。。。而AvField的validate中验证是非负整数，两个验证冲突？？？（或许是）</p>
<p>​        第四次尝试</p>
<p>​                在第三次的基础上加入onKeyDown，输入非预期的字符则调用e.preventDefault()，嗯，这下子不能输入负号了。。。。。最后测试，发现这样不能避免Ctrl C/V，还有浏览器剪切板粘贴。。。后期考虑再改为onMouseDown了.</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器学习笔记</title>
    <url>/2020/09/03/date200903/</url>
    <content><![CDATA[<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>*<strong>浏览器*<strong>，是一个用于检索，展示和遍历在万维网的信息资源的软件应用程序。信息资源被定义成</strong>统一资源定位符</strong>（URI/URL)。它可能是网页，图片，视频或者一个内容片段。超链接的出现使用户能轻松的将浏览器导航到相关的资源。虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。<br>浏览器主要由js引擎和渲染引擎组成</p>
<span id="more"></span>

<p><img src="/images/post200903.png" alt="常见浏览器内核"></p>
<h2 id="主要组件："><a href="#主要组件：" class="headerlink" title="主要组件："></a>主要组件：</h2><ul>
<li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。<br>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。<br>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。<br>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>
<li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。<br>JavaScript 解释器。用于解析和执行 JavaScript 代码。<br>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<h2 id="四大内核："><a href="#四大内核：" class="headerlink" title="四大内核："></a>四大内核：</h2><h3 id="1-Trident"><a href="#1-Trident" class="headerlink" title="1. Trident"></a>1. Trident</h3><p>***IE浏览器内核***，俗称IE内核，代表产品是Internet Explorer，它是微软开发的一种排版引擎。在1997年10月与IE4一起诞生，不断地更新和完善，Trident是一款开放的内核，其引擎被设计成一个软件模块，接口内核设计相当成熟，因此涌现出许多采用IE内核而非IE的浏览器，如：百度浏览器、腾讯TT、遨游、世界之窗等，但是Trident只能用于Windows平台且不开源（这也是为什么mac上不用ie浏览器的原因），而且由于曾经市场份额比较大，脱离W3C标准，同时IE版本比较多，本身存在一些BUG和很多的兼容性问题</p>
<p><strong>优点：</strong>市场份额较大，接口内核设计成熟</p>
<p><strong>缺点：</strong>不开源，只能用于Windows平台，曾经与W3C标准脱节，对真正的网页标准支持不是很友好，低版本存在很多的兼容性问题</p>
<h3 id="2-webkit"><a href="#2-webkit" class="headerlink" title="2. webkit"></a>2. webkit</h3><p><strong>Safari浏览器内核</strong>，主要代表产品有Safari和Chrome 28以下版本（Chrome 28+改用Blink内核），它的特点在于源码结构清晰、渲染速度极快。它在手机上的应用也十分广泛，例如Google的Android平台浏览器、Apple的iPhone浏览器、Nokia S60浏览器等。 WebKit内核也广泛应用于Widget引擎产品，包括中国移动的BAE、Apple的Dashboard以及Nokia WRT等。</p>
<p><strong>优点：</strong>开源，安全，网页浏览速度较快，不及 Presto 但是也胜于 Gecko 和 Trident，手机上应用广泛</p>
<p><strong>缺点：</strong>系统资源占用较高，对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示</p>
<h3 id="3-Presto"><a href="#3-Presto" class="headerlink" title="3. Presto"></a>3. Presto</h3><p>它是目前公认的网页浏览速度最快的浏览器内核，然而代价是牺牲了网页的兼容性。代表作品是*<strong>Opera*</strong> （Opera12.17及更早版本曾经采用的内核，现已停止开发并废弃），它的特点是渲染速度达到了极致，Presto实际上是一个动态内核，供Opera 7.0+使用。它取代了旧版Opera 4~6版本使用的Elektra排版引擎，网页或其部分可随着DOM及Script语法的事件而重新排版。它与Trident、Gecko等内核的最大区别就在于脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。此外该内核在执行JavaScript时有着最快的速度，同等条件下，Presto内核执行同等JavaScript所需的时间仅有Trident和Gecko内核的约1/3。Presto是商业引擎，在一定程度上限制了Presto的发展，由于市场选择问题，主要应用在手机平台–Opera mini<br>Opera 15+已改用Google Chrome的Blink内核。在2013年之后，Opera宣布加入谷歌阵营，弃用了Presto</p>
<p><strong>优点：</strong>速度快，动态内核，脚本处理上有着天生的优势</p>
<p><strong>缺点：</strong>商业引擎，为了达到很快的速度而丢掉了一部分网页兼容性</p>
<h3 id="4-Gecko"><a href="#4-Gecko" class="headerlink" title="4.Gecko"></a>4.Gecko</h3><p>***Firefox浏览器内核***，代表是Mozilla Firefox，由于Gecko的特点是开源，因此，其可开发程度很高，因此受到许多人的青睐，采用Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因，Gecko排版引擎提供了一个丰富的程序界面以供与互联网相关的应用程序使用，例如网页浏览器、HTML编辑器、客户端/服务器等。虽然最初的主要对象是Mozilla的衍生产品，如Netscape和Mozilla Firefox，但是现在已有很多其他软件利用这个排版引擎。此外Gecko也是一个跨平台内核，可以在Windows、BSD、Linux和Mac OS X中使用。<br>正在和曾经使用Gecko引擎的浏览器有Firefox、网景6～9、SeaMonkey、Camino、Mozilla、Flock、Galeon、K-Meleon、Minimo、Sleipni、Songbird、XeroBank。GoogleGadget</p>
<p><strong>优点：</strong>开源，扩展性强，可开发程度很高，功能强大、丰富，跨平台</p>
<p><strong>缺点：</strong>数据档案保存能力弱，要消耗很多的资源，比如内存</p>
]]></content>
  </entry>
  <entry>
    <title>常见分辨率归纳总结</title>
    <url>/2020/09/04/date20090401/</url>
    <content><![CDATA[<p><strong>常见PC使用分辨率</strong></p>
<p>1024*600 （常见8.9寸电脑使用）</p>
<p>1024*768（常用10.4、12.1、14.1、15寸电脑使用）4:3</p>
<p>1280*1024（常用14.1、15寸电脑使用）5:4</p>
<p>1600 * 900 16:9 (非主流)</p>
<p>1440*1050（常用15、16.1寸电脑使用）4:3</p>
<p>1600*1200（常用15、16.1寸电脑使用）4:3</p>
<span id="more"></span>

<p>1280*800（常见10.8、12.1、15.4寸电脑使用）16:10</p>
<p>1366*768（常见15.2寸电脑使用）15:10 （主流）</p>
<p>1280*854（不常见）16:9</p>
<p>1440*900（仅苹果17寸电脑使用）16:10</p>
<p>1600*1024（不常见）14:9</p>
<p>1680*1050（常见15.4、20寸电脑使用）16:10</p>
<p>1920*1080 16:9 （主流）</p>
<p>1920*1200（常见20寸电脑使用）16:10</p>
<p><strong>常见平板分辨率</strong></p>
<p>768x1024 — 75.65%</p>
<p>360x640 — 2.85%</p>
<p>1024x768 — 1.94%</p>
<p>800x1280 — 1.58%</p>
<p>1920x1080 — 1.37%</p>
<p>1024x1366 — 1.26%</p>
]]></content>
  </entry>
  <entry>
    <title>JS中关于截取的若干方法</title>
    <url>/2020/09/03/date20090404/</url>
    <content><![CDATA[<h4 id="1-slice"><a href="#1-slice" class="headerlink" title="1.slice"></a>1.slice</h4><p><strong>定义：</strong>用于<strong>数组</strong>的截取，返回一个新的数组对象，这一对象是一个由 begin和 end决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</p>
<span id="more"></span>

<p><strong>语法：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; arr.slice([begin[,end]]) </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>begin(可选)</th>
<th>end（可选）</th>
</tr>
</thead>
<tbody><tr>
<td>提取起始处的索引（从 <code>0</code> 开始），从该索引开始提取原数组元素。</td>
<td>提取终止处的索引（从 <code>0</code> 开始），在该索引处结束提取原数组元素。<code>slice</code> 会提取原数组中索引从 <code>begin</code> 到 <code>end</code> 的所有元素（包含 <code>begin</code>，但不包含 <code>end</code>）。</td>
</tr>
</tbody></table>
<p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1,2,3,4];</span><br><span class="line">console.log(arr.slice(2)); //3,4</span><br><span class="line">console.log(arr.slice(2,3)); //3</span><br></pre></td></tr></table></figure>

<h4 id="2-split"><a href="#2-split" class="headerlink" title="2.split"></a>2.split</h4><p><strong>定义：</strong>用于<strong>字符串</strong>的截取，使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分个字串来决定每个拆分的位置</p>
<p><strong>语法：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; str.split([separator[, limit]])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>separator</th>
<th>limit</th>
</tr>
</thead>
<tbody><tr>
<td>指定表示每个拆分应发生的点的字符串。<code>separator</code> 可以是一个字符串或<strong>正则表达式</strong>。 如果纯文本分隔符包含多个字符，则必须找到整个字符串来表示分割点。如果在str中省略或不出现分隔符，则返回的数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将str原字符串中每个字符的数组形式返回。</td>
<td>一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。</td>
</tr>
</tbody></table>
<p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str=&quot;1,2,3,4,5&quot;;</span><br><span class="line">const word=str.split(&quot;,&quot;);</span><br><span class="line">console.log(word);//[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<h4 id="3-splice"><a href="#3-splice" class="headerlink" title="3.splice"></a>3.splice</h4><p><strong>定义：</strong>用于<strong>数组</strong>修改或截取</p>
<p><strong>语法：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>start</th>
<th>deleteCount可选</th>
<th>item1,item2,…可选</th>
</tr>
</thead>
<tbody><tr>
<td>指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于<code>array.length-n</code>）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。</td>
<td>整数，表示要移除的数组元素的个数。</td>
<td>要添加进数组的元素,从<code>start</code> 位置开始。如果不指定，则 <code>splice()</code> 将只删除数组元素。</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cons arr = [1,2,3,4];</span><br><span class="line">arr.splice（1,0,5);</span><br><span class="line">//在索引为1的位置插入5</span><br><span class="line">console.log(arr);//[1,5,2,3,4]</span><br><span class="line"></span><br><span class="line">arr.splice(0,1,0);</span><br><span class="line">//从第0个位置开始删除一个元素，插入0  将1替换为0</span><br><span class="line">console.log(arr);//[0,5,2,3,4]</span><br><span class="line"></span><br><span class="line">arr.splice(2,2);</span><br><span class="line">//从第2个位置开始删除2个元素</span><br><span class="line">console.log(arr);//[0,5,4]</span><br><span class="line"></span><br><span class="line">arr.splice(1,1,2,3,4)</span><br><span class="line">//从第1个位置开始删除1个元素，并插入2,3,4</span><br><span class="line">console.log(arr);//[0,2,3,4,4]</span><br></pre></td></tr></table></figure>

<h4 id="4-substring"><a href="#4-substring" class="headerlink" title="4.substring"></a>4.substring</h4><p><strong>定义：</strong>用于<strong>字符串</strong>的截取，</p>
<p><strong>语法：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; str.subtring(indexStart[,indexEnd])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>indexStart</th>
<th>indexEnd</th>
</tr>
</thead>
<tbody><tr>
<td>需要截取的第一个字符的索引，该索引位置的字符作为返回的字符串的首字母。</td>
<td>可选。一个 0 到字符串长度之间的整数，以该数字为索引的字符不包含在截取的字符串内。</td>
</tr>
</tbody></table>
<p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var anyString = &quot;1234567&quot;;</span><br><span class="line"></span><br><span class="line">// 输出 &quot;123&quot;</span><br><span class="line">console.log(anyString.substring(0,3));</span><br><span class="line">console.log(anyString.substring(3,0));</span><br><span class="line">console.log(anyString.substring(3,-3));</span><br><span class="line">console.log(anyString.substring(3,NaN));</span><br><span class="line">console.log(anyString.substring(-2,3));</span><br><span class="line">console.log(anyString.substring(NaN,3));</span><br><span class="line"></span><br><span class="line">// 输出 &quot;567&quot;</span><br><span class="line">console.log(anyString.substring(4,7));</span><br><span class="line">console.log(anyString.substring(7,4));</span><br><span class="line"></span><br><span class="line">// 输出 &quot;&quot;</span><br><span class="line">console.log(anyString.substring(4,4));</span><br><span class="line"></span><br><span class="line">// 输出 &quot;123456&quot;</span><br><span class="line">console.log(anyString.substring(0,6));</span><br><span class="line"></span><br><span class="line">// 输出 &quot;1234567&quot;</span><br><span class="line">console.log(anyString.substring(0,7));</span><br><span class="line">console.log(anyString.substring(0,10));</span><br></pre></td></tr></table></figure>

<h4 id="5-substr"><a href="#5-substr" class="headerlink" title="5.substr"></a>5.substr</h4><p>尽管 <code>String.prototype.substr(…)</code> 没有严格被废弃 (as in “removed from the Web standards”), 但它被认作是遗留的函数并且可以的话应该避免使用。它并非JavaScript核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 <code>substring()</code> 替代它.</p>
]]></content>
  </entry>
  <entry>
    <title>常见色彩格式</title>
    <url>/2020/09/04/date20090403/</url>
    <content><![CDATA[<h3 id="常见色彩格式"><a href="#常见色彩格式" class="headerlink" title="常见色彩格式"></a>常见色彩格式</h3><p><strong>RGB （red,green,blue)</strong></p>
<p><strong>HSV Hue(色相)、Saturation(饱和度)、Value(色调)</strong></p>
<p><strong>HSL （Hue(色相)、Saturation(饱和度)、Lightness(亮度)）</strong></p>
<span id="more"></span>

<p>附录：</p>
<h5 id="JavaScript中rgb转换为hsv"><a href="#JavaScript中rgb转换为hsv" class="headerlink" title="JavaScript中rgb转换为hsv"></a>JavaScript中rgb转换为hsv</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//rbg范围为[0,255]，转换成h的范围为[0,360]</span><br><span class="line">//s,v为百分比形式，范围是[0,100],可根据需求做相应调整</span><br><span class="line">function rgbtohsv(r,g,b)&#123;</span><br><span class="line">    r=r/255;</span><br><span class="line">    g=g/255;</span><br><span class="line">    b=b/255;</span><br><span class="line">    var h,s,v;</span><br><span class="line">    var min=Math.min(r,g,b);</span><br><span class="line">    var max=v=Math.max(r,g,b);</span><br><span class="line">    var l=(min+max)/2;</span><br><span class="line">    var diff = max-min;</span><br><span class="line">    </span><br><span class="line">    if(max==min)&#123;</span><br><span class="line">        h=0</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        switch(max)&#123;</span><br><span class="line">            case r: h=(g-b)/diff+(g&lt;b?6:0);break;</span><br><span class="line">            case g: h=2.0+(b-r)/diff;break;</span><br><span class="line">            case b: h=4.0+(r-g)/diff;break;</span><br><span class="line">        &#125;</span><br><span class="line">        h=Math.round(h*60);</span><br><span class="line">    &#125;</span><br><span class="line">    if(max==0)&#123;</span><br><span class="line">        s=0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        s=1-min/max;</span><br><span class="line">    &#125;</span><br><span class="line">    s=Math.round(s*100);</span><br><span class="line">    v=Math.round(v*100);</span><br><span class="line">    return [h,s,v];</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ES语法糖</title>
    <url>/2020/09/04/date20090402/</url>
    <content><![CDATA[<p><strong>一. ?.（可选链）</strong></p>
<p><strong>1、长判断时用：在开发中，对接口返回的嵌套对象数据进行属性判断。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let res = &#123;</span><br><span class="line">  code: 200,</span><br><span class="line">  data: &#123;</span><br><span class="line">    content: [1,2,3], //table list</span><br><span class="line">    page: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  message: &#x27;success&#x27;,</span><br><span class="line">  func: function()&#123;console.log(&#x27;I am func&#x27;)&#125;</span><br><span class="line">&#125;</span><br><span class="line">const tableList = res.data &amp;&amp; res.data.content; //[1,2,3]</span><br><span class="line">// 相当于</span><br><span class="line">const tableList = res.data ? res.data.content : undefined;</span><br><span class="line">// 有了可选链, 简写为</span><br><span class="line">const tableList = res.data?.content  //[1,2,3]</span><br><span class="line"></span><br><span class="line">// 甚至更谨慎点，加长判断，多个三目运算</span><br><span class="line">const tableList = res &amp;&amp; res.data &amp;&amp; res.data.content; </span><br><span class="line">// 有了可选链, 简写为</span><br><span class="line">const tableList = res?.data?.content  //[1,2,3]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>2、调用函数或方法时用：调用前先判断是否是存在</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引用上文例子 </span><br><span class="line">const tableList = res &amp;&amp; res.func &amp;&amp; res.func();  </span><br><span class="line">// 有了可选链，简写为 </span><br><span class="line">const func = res?.func?.() // I am func 或者 res.func?.() </span><br><span class="line">const func = res?.test?.() // undefined</span><br></pre></td></tr></table></figure>

<p><strong>3、动态属性：属性为变量时用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引用上文例子 </span><br><span class="line">const name = &#x27;data&#x27;; </span><br><span class="line">res?.[name]?.content  // [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>二. ??（双问号）</strong></p>
<p>使用场景: 取默认值</p>
<p>实际上接口返回的数据中，content很可能为null 或者 undefined，或压根没返回content，因此我们判断时需要加上默认值，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let res = &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    content: null, // or false, or 0,</span><br><span class="line">    content1: false,</span><br><span class="line">    content2: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 加上默认值</span><br><span class="line">const tableList = res?.data?.content || [4,5,6]  //[4,5,6]</span><br><span class="line">// 但我们发现，对于||，返回false或者0，也会取后者</span><br><span class="line">const tableList = res?.data?.content1 || [4,5,6]  //[4,5,6]</span><br><span class="line">const tableList = res?.data?.content2 || [4,5,6]  //[4,5,6]</span><br></pre></td></tr></table></figure>

<p>在想返回null和undefined的时候取双问号后面的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意点： </span><br><span class="line">undefined ?? &#x27;default&#x27; // &#x27;default&#x27; </span><br><span class="line">null ?? &#x27;default&#x27; // &#x27;default&#x27; </span><br><span class="line">false ?? &#x27;default&#x27; // &#x27;false&#x27; </span><br><span class="line">0 ?? &#x27;default&#x27; // 0</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>webpack归纳总结</title>
    <url>/2020/09/04/date20090406/</url>
    <content><![CDATA[<h3 id="关于webpack"><a href="#关于webpack" class="headerlink" title="关于webpack"></a>关于webpack</h3><p><strong>webpack是现代JavaScript应用程序的静态模块打包工具</strong></p>
<ul>
<li>bundle（包，束）</li>
<li>入口（entry）</li>
<li>输出（output）</li>
<li>loader</li>
<li>插件（plugin）</li>
<li>模式（mode）</li>
<li>浏览器兼容性（browser compatibility）</li>
</ul>
<span id="more"></span>

<p><strong>1.入口</strong></p>
<p>入口文件只是webpack应该使用哪个模块来作为构建内部依赖图的开始。进入入口文件起点后，webpack会找出有哪些模块和库时候入口起点（直接和间接）依赖的</p>
<p>默认值是 ./src/index.js</p>
<p>可以通过在webpack configuration中配置entry属性，来指定一个或多个不用入口的起点，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;      entry: &#x27;./path/to/my/entry/file.js&#x27;    &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2.输出</strong></p>
<p>输出（output） 告诉webpack在哪里输出它所创建的bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中</p>
<p>可以通过配置中指定一个output字段，来配置这些处理过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;); </span><br><span class="line">module.exports = &#123;  </span><br><span class="line">	entry: &#x27;./path/to/my/entry/file.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">    	path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;my-first-webpack.bundle.js&#x27;  </span><br><span class="line">       &#125; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3.loader</strong></p>
<p>webpack只能理解JavaScript和Json文件。loader让webpack能够去处理其他类型的文件并将它们转换为有效模块，以供应用程序使用</p>
<p>注意：loader能够import导入任何类型的模块（例如.css文件），这是webpack特有的功能，其他打包程序或任务执行器可能并不支持</p>
<p>在更高层面，webpack的配置中oader有两个属性：</p>
<p>1.test属性，用于标识出应该被对应的loader进行转换的某个或某些文件</p>
<p>2.use属性，标识进行转换时，应该使用哪个loader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;); </span><br><span class="line">module.exports = &#123;  </span><br><span class="line">	output: &#123;</span><br><span class="line">    filename: &#x27;my-first-webpack.bundle.js&#x27;</span><br><span class="line">    &#125;,  </span><br><span class="line">    module: &#123;</span><br><span class="line">    	rules: [    </span><br><span class="line">    	//告诉编译器在遇到后缀为txt文件时，需要使用raw-loader转换    </span><br><span class="line">    	//此处注意test不要添加引号     </span><br><span class="line">        	&#123; test: /\.txt$/, use: &#x27;raw-loader&#x27; &#125;    </span><br><span class="line">        	]  </span><br><span class="line">        &#125; </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>background，border的各种妙用---不常用属性补充说明</title>
    <url>/2020/12/16/date201216/</url>
    <content><![CDATA[<h3 id="1-如何将指定图片源作为边框？"><a href="#1-如何将指定图片源作为边框？" class="headerlink" title="1.如何将指定图片源作为边框？"></a>1.如何将指定图片源作为边框？</h3><p> 答：border-image-source+border-image-slice</p>
<p> 知识点补充：通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image-source"><code>border-image-source</code></a>引用边框图片后，**<code>border-image-slice</code>**属性拆分图片分割为9 个区域：四个角，四个边（edge）以及中心区域。四条切片线，从它们各自的侧面设置给定距离，控 制区域的大小。</p>
<span id="more"></span>

<p> <img src="/images/post20121601.png" alt="示意图"></p>
<ul>
<li>区域1-4为角区域（corner region）。每个一个都用一次来形成最终边界图像的角点。（每次使用一次形成最终边界图像的角。）</li>
<li>区域5-8边区域（边缘区域）。在最终的边框图像中重复，缩放或修改其以匹配元素的尺寸。（这些在最终边框图像中被重复，缩放或以 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-repeat">其他方式修改</a> ，以匹配边框的尺寸）。元件。）</li>
<li>区域9为中心区域（middle region）。它在情况下下会被替换，但如果设置了关键字<code>fill</code>，将会将其用作背景图像。（默认情况下将其丢弃，但如果关键字 <code>fill</code> 已设置。）</li>
</ul>
<p>border-image-slice语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 所有的边 */</span><br><span class="line">border-image-slice: 30%;</span><br><span class="line"></span><br><span class="line">/* 垂直方向 | 水平方向 */</span><br><span class="line">border-image-slice: 10% 30%;</span><br><span class="line"></span><br><span class="line">/* 顶部 | 水平方向 | 底部 */</span><br><span class="line">border-image-slice: 30 30% 45;</span><br><span class="line"></span><br><span class="line">/* 上 右 下 左 */</span><br><span class="line">border-image-slice: 7 12 14 5;</span><br><span class="line"></span><br><span class="line">/* 使用fill（fill可以放在任意位置） */</span><br><span class="line">border-image-slice: 10% fill 7 12;</span><br><span class="line"></span><br><span class="line">/* Global values */</span><br><span class="line">border-image-slice: inherit;</span><br><span class="line">border-image-slice: initial;</span><br><span class="line">border-image-slice: unset;</span><br></pre></td></tr></table></figure>

<h3 id="2-如何在遮罩上显示一个logo或动画？"><a href="#2-如何在遮罩上显示一个logo或动画？" class="headerlink" title="2.如何在遮罩上显示一个logo或动画？"></a>2.如何在遮罩上显示一个logo或动画？</h3><p> 答：定义两个容器然后用绝对定位叠加显示？nonono，background-blend-mode可以帮你解决这个问 题；利用backgound-image定义两个图片源，再用background-blend-mode选择叠加效果。</p>
<p> 知识点补充：background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。</p>
<p><strong>注意:</strong> Internet Explorer 不支持 background-blend-mode 属性。</p>
<p>background-blend-mode语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-blend-mode: normal|multiply|screen|overlay|darken|lighten|color-dodge|saturation|color|luminosity;</span><br></pre></td></tr></table></figure>

<p>background-blend-mode属性值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值。设置正常的混合模式。</td>
</tr>
<tr>
<td>multiply</td>
<td>正片叠底模式。</td>
</tr>
<tr>
<td>screen</td>
<td>滤色模式。</td>
</tr>
<tr>
<td>overlay</td>
<td>叠加模式。</td>
</tr>
<tr>
<td>darken</td>
<td>变暗模式。</td>
</tr>
<tr>
<td>lighten</td>
<td>变亮模式。</td>
</tr>
<tr>
<td>color-dodge</td>
<td>颜色减淡模式。</td>
</tr>
<tr>
<td>saturation</td>
<td>饱和度模式。</td>
</tr>
<tr>
<td>color</td>
<td>颜色模式。</td>
</tr>
<tr>
<td>luminosity</td>
<td>亮度模式</td>
</tr>
</tbody></table>
<h3 id="3-如何制定一个固定的背景图片？"><a href="#3-如何制定一个固定的背景图片？" class="headerlink" title="3.如何制定一个固定的背景图片？"></a>3.如何制定一个固定的背景图片？</h3><p> 答：background-attachment</p>
<p>background-attachment属性值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>scroll</td>
<td>背景图片随着页面的滚动而滚动，这是默认的。</td>
</tr>
<tr>
<td>fixed</td>
<td>背景图片不会随着页面的滚动而滚动。</td>
</tr>
<tr>
<td>local</td>
<td>背景图片会随着元素内容的滚动而滚动。</td>
</tr>
<tr>
<td>initial</td>
<td>设置该属性的默认值。</td>
</tr>
<tr>
<td>inherit</td>
<td>指定 background-attachment 的设置应该从父元素继承。</td>
</tr>
</tbody></table>
<h3 id="4-如何为容器指定区域填充背景色？"><a href="#4-如何为容器指定区域填充背景色？" class="headerlink" title="4.如何为容器指定区域填充背景色？"></a>4.如何为容器指定区域填充背景色？</h3><p>答：background-clip可以将容器内除padding以外的区域填充</p>
<p>background-clip属性值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>border-box</td>
<td>默认值。背景绘制在边框方框内（剪切成边框方框）。</td>
</tr>
<tr>
<td>padding-box</td>
<td>背景绘制在衬距方框内（剪切成衬距方框）。</td>
</tr>
<tr>
<td>content-box</td>
<td>背景绘制在内容方框内（剪切成内容方框）。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>windows10 环境下安装MySQL 8.0.20</title>
    <url>/2020/12/28/date201218/</url>
    <content><![CDATA[<h3 id="一-从官网（mysql-com）下载安装包"><a href="#一-从官网（mysql-com）下载安装包" class="headerlink" title="一 . 从官网（mysql.com）下载安装包"></a>一 . 从官网（mysql.com）下载安装包</h3><ol>
<li> 打开官网点击顶部导航栏中的DOWNLOADS按钮，点击下发下方MySQL Community（GPL) Downloads&gt;&gt;</li>
</ol>
   <span id="more"></span>

<p>   <img src="/images/post20122801.png" alt="示意图一"></p>
<ol start="2">
<li><p>点击MySQL Community Server</p>
<p><img src="/images/post20122802.png" alt="示意图二"></p>
</li>
<li><p>在下拉菜单中，选择windows（一般默认就是windows），然后点击下方的Download</p>
<p><img src="/images/post20122803.png" alt="示意图三"></p>
</li>
<li><p>在打开的页面中，选择 <strong>No thanks, just start my download.</strong> ，然后开始下载MySql zip安装包</p>
<p><img src="/images/post20122804.png" alt="示意图四"></p>
</li>
</ol>
<h3 id="二-配置环境变量"><a href="#二-配置环境变量" class="headerlink" title="二.配置环境变量"></a>二.配置环境变量</h3><ol>
<li><p>将下载好的zip包解压到指定目录，例如E:\mysql-8.0.22-winx64</p>
</li>
<li><p>添加环境变量，“此电脑”图标游击属性，点击环境变量，在系统变量一栏点击Path，选中点击编辑，进入新建，将解压的目录的bin（E:\mysql-8.0.22-winx64\bin) 添加到Path下</p>
<p><img src="/images/post20122805.png" alt="示意图五"></p>
</li>
<li><p>点击确定，完成创建，关闭窗口</p>
</li>
<li><p>windows键+R 键入cmd打开命令窗口（以管理员身份打开）</p>
</li>
<li><p>在命令行窗口中输入以下命令，进行初始化。初始化后，MySql 安装目录会出现一个 data目录（请勿手动创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure>

<p>随后，控制台返回如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-07-04T08:37:16.188232Z 0 [System] [MY-013169] [Server] E:\mysql-8.0.20-winx64\bin\mysqld.exe (mysqld 8.0.20) initializing of server in progress as process 14880</span><br><span class="line">2020-07-04T08:37:16.196858Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.</span><br><span class="line">2020-07-04T08:37:46.330192Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.</span><br><span class="line">[Note] [MY-010454] [Server] A temporary password is generated for root@localhost:************</span><br></pre></td></tr></table></figure>

<p>**<em>*</em>****即为 MySql 数据库 root 用户初始密码，后面初次登陆时需要使用，初始密码一定要记住，不然重置密码很麻烦</p>
</li>
<li><p>使用 <strong>mysqld –install</strong> 命令进行数据库安装</p>
<p>正常情况下返回信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Service successfully installed.</span><br></pre></td></tr></table></figure>

<p>失败的情况</p>
<ul>
<li><p>返回 <strong>Install/Remove of the Service Denied</strong> ，意味权限不足</p>
<p> 解决方案：使用管理员身份运行 cmd</p>
</li>
<li><p> 返回 <strong>The service already exists</strong> ，意味已存在MySql 服务</p>
</li>
</ul>
<p>  解决方案：在命令行窗口中，输入 <strong>mysqld -remove</strong>，若提示 **Service successfully removed.**，则成功卸载，重新执行 install 命令</p>
</li>
<li><p>在命令行中输入 <strong>net start mysql</strong> 命令，启动 mysql 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p>启动成功返回信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL 服务正在启动 .....</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<p>若启动失败，则：</p>
<ol>
<li><p>检查 MySql 使用的 3306 端口是否被其他进程占用。</p>
</li>
<li><p>检查安装目录中是否存在 <strong>my.ini</strong> 文件，若存在则删除该文件</p>
<p>（网上的其他安装教程让创建这个配置文件，但是在8.0.20版本，<strong>存在这个文件，MySql 服务便无法启动</strong>，删除重新启动MySql服务即可）</p>
</li>
</ol>
</li>
</ol>
<h3 id="三-登录并配置MySQL"><a href="#三-登录并配置MySQL" class="headerlink" title="三.登录并配置MySQL"></a>三.登录并配置MySQL</h3><p> 1.在命令行中输入 <strong>mysql -u root -p</strong> ，并使用前文 安装 MySql 前进行初始化，返回的 root 用户初始密码 进行登录（可 能不能直接粘贴输入，如果提示登陆失败，请尝试手动输入）</p>
<p> 登陆成功后，控制台会输出如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 9</span><br><span class="line">Server version: 8.0.20</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>注意：输出信息中有提示sql命令结尾要加；或\g</p>
<p> 2.进行其他操作前，必须先将 初始密码 进行重置，否则系统会报错提示我们：“**ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.**”</p>
<p> 我们使用如下 sql 语句进行初始密码重置，<strong><em>* *</em>*</strong>**** * 处，请填写您希望设定的 root 用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;*********&#x27;;</span><br></pre></td></tr></table></figure>

<p> 设定成功后，控制台会显示：<strong>Query OK, 0 rows affected (0.55 sec)</strong></p>
<h3 id="四-其他事项"><a href="#四-其他事项" class="headerlink" title="四.其他事项"></a>四.其他事项</h3><ol>
<li><p>创建其他用户：**CREATE USER ‘————‘@’localhost’ IDENTIFIED BY ‘*******<em><strong>‘;</strong> ———— 此处为用户名 <strong><em>*</em>**</strong></em> 此处为用户密码</p>
</li>
<li><p>退出MySql命令：<strong>quit;</strong></p>
</li>
<li><p>关闭 MySql 服务命令：<strong>net stop mysql</strong></p>
</li>
<li><p>创建其他用户：**CREATE USER ‘————‘@’localhost’ IDENTIFIED BY ‘*******<em><strong>‘;</strong> ———— 此处为用户名 <strong><em>*</em>**</strong></em> 此处为用户密码</p>
<p>退出MySql命令：<strong>quit;</strong></p>
<p>关闭 MySql 服务命令：<strong>net stop mysql</strong></p>
</li>
</ol>
<p>[^摘录自]: 作者：冬酒暖阳 链接：<a href="https://juejin.cn/post/6850418115450175495">https://juejin.cn/post/6850418115450175495</a> 来源：掘金</p>
]]></content>
  </entry>
  <entry>
    <title>查找数组中是否包含某元素的若干方法</title>
    <url>/2020/09/04/date20090405/</url>
    <content><![CDATA[<p>假设变量a为某数组，该数组包含若干个元素，b为已知元素，要判断b是否在a中</p>
<p><strong>1.indexOf</strong></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let c = a.indexOf(b) </span><br><span class="line">//如果b为对象或数组，则需要将a序列化后再操作  let c=JSON.stringtify(a).index   </span><br><span class="line">if(c&lt;0)&#123;</span><br><span class="line">    console.log(&quot;b在a中&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    console.log(&quot;b不在a中&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.find（方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let c = a.find(item=&gt; return item==b) </span><br><span class="line">if(c)&#123;    </span><br><span class="line">    console.log(&quot;b在a中&quot;); </span><br><span class="line">&#125;else&#123;    </span><br><span class="line">    console.log(&quot;b不在a中&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.map遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let res = false;</span><br><span class="line">const c=a.map(v=&gt;&#123;</span><br><span class="line">	if(v==b)&#123;</span><br><span class="line">	res = true;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(c);//b在a中返回true否则返回false</span><br></pre></td></tr></table></figure>

<p><strong>4.some是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const c=a.some(v=&gt;v=b);</span><br><span class="line">console.log(c);//b在a中则输出true否则输出false</span><br></pre></td></tr></table></figure>

<p><strong>注意：every和some的区别：</strong></p>
<ul>
<li><strong>every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。</strong></li>
<li><strong>some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。</strong></li>
</ul>
<p><strong>5.includes函数用来判断一个数组是否包含一个指定的值，如果包含则返回true，否则返回false。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let c=a.includes(b) </span><br><span class="line">if(c)&#123;    </span><br><span class="line">	console.log(&quot;b在a中&quot;); </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    console.log(&quot;b不在a中&quot;) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>defaultValue 与 Value 的使用</title>
    <url>/2022/03/20/note02/</url>
    <content><![CDATA[<p>问题起因：某天boss在例行检查代码的时候，把所有的value换成了defaultValue，原因是他说value的值是从props过来的，props的值改变会影响value，而defaultValue可以避免这个问题….（黑人问号脸.jpg)，啊这不是吧，源数据改变就算换成defaultValue也会改变的吧，难道是我一直理解错了？于是本着辨证的目的我打算互联网冲浪去寻找原因…</p>
<span id="more"></span>

<p>在查阅了一些资料文献后我发现了这样一段话可以解答我的疑惑</p>
<blockquote>
<p><strong>React 中为何需要defaultValue？</strong></p>
<p>defaultValue 一般用于表单，给表单元素一个初始化值。注意，只是初始化，如果defaultValue值发生变化，表单里的值不会被改变。</p>
<p><strong>value也可以做到，为何还要defaultValue呢？</strong></p>
<p>表单分两种，一种是受控表单，一种是非受控表单。仅用value，使用者会误以为value值改变，表单显示的值也会跟着变，这实际上是受控表单的行为，完全符合期望。但是，非受控表单，props.value变化，其表单显示的值不会跟着变（因为表单内部有自己的state），为了区别这两种场景，所以引入了defaultValue，表示只给默认值。</p>
</blockquote>
<p>果然是基础知识不扎实，看到这儿，我大概理解了boss为什么将原来的value onChange搭配改为了defaultValue onBlur；原来的搭配会在键入的时候频繁的执行setState去更改数值，改为非受控组件后，并在失去焦点的时候赋值，避免了大数据列表因为不断更改值应发的性能问题，真真儿nice</p>
]]></content>
  </entry>
  <entry>
    <title>welcome to my zone</title>
    <url>/2019/08/15/note1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>欢迎来到AreUhungry的个人博客，该博客创建于2019年8月15日一个风和日丽的下午，以后博客会不定期更新一些个人的生活状态和学习笔记，如果机缘巧合翻到这个网站实属荣幸，留下你的足迹一人送博主五个油腻么么哒。</p>
</blockquote>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip:"></a>Tip:</h3><blockquote>
<p><em>小女拙见如与阁下观点不胜雷同还望多多包涵，所po内容引起不适请点击右上角x</em>。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>React学习笔记</title>
    <url>/2020/12/11/date201211/</url>
    <content><![CDATA[<p><strong>第一章：开始</strong></p>
<p><strong>react特性</strong></p>
<p>高效：通过虚拟DOM实现对dom元素的批量修改，减少操作次数</p>
<p>diff算法：</p>
<span id="more"></span>

<p><strong>知识体系图</strong></p>
<p><img src="/images/post20121101.png" alt="知识体系"></p>
<p>简单代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html&#123;    </span><br><span class="line">	&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; </span><br><span class="line">	&#125; </span><br><span class="line">JS&#123;    </span><br><span class="line">ReactDOM.render(  </span><br><span class="line">	&lt;h1&gt;Hello, world!&lt;/h1&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JS知识前置：</strong></p>
<ul>
<li><strong>概述：</strong>JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。</li>
<li><strong>类型：</strong>Number（数字）</li>
</ul>
<p> String（字符串）</p>
<p> Boolean（布尔）</p>
<p> Object（对象）：</p>
<p> Function（函数）</p>
<p> Array（数组）</p>
<p> Date（日期）</p>
<p> Regexp（正则表达式）</p>
<p> Symbol（ES2015 新增）</p>
<p> null（空）</p>
<p> undefined（未定义）</p>
<ul>
<li>const定义的变量不可以修改，而且必须初始化</li>
<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</li>
<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。</li>
<li>如果给定的字符串不存在数值形式，函数会返回一个特殊的值 NaN（Not a Number 的缩写）</li>
</ul>
<p><strong>第二章：关于JSX</strong></p>
<p><strong>定义：JSX，是一个 JavaScript 的语法扩展。</strong></p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>发现一个有趣的现象，jsx的变量声明位于function函数后，即先使用后声明</li>
<li>在 JSX 语法中，大括号内放置可任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。</li>
<li>在下面的示例中，JavaScript 函数 formatName(user) 的结果，并将结果嵌入到 &lt; h1&gt; 元素中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function formatName(user) &#123;  </span><br><span class="line">    return user.firstName + &#x27; &#x27; + user.lastName; </span><br><span class="line">&#125; </span><br><span class="line">const user = &#123;  </span><br><span class="line">    firstName: &#x27;Harper&#x27;,  lastName: &#x27;Perez&#x27; </span><br><span class="line">&#125;; </span><br><span class="line">const element = (  &lt;h1&gt;    Hello, &#123;formatName(user)&#125;!  &lt;/h1&gt; ); </span><br><span class="line">ReactDOM.render(  element,  document.getElementById(&#x27;root&#x27;));  </span><br><span class="line">//获取id为root的块级元素，将第一个参数中的名为element的变量内容渲染到容器中</span><br></pre></td></tr></table></figure>

<ul>
<li>建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱</li>
<li>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getGreeting(user) &#123;  </span><br><span class="line">    if (user) &#123;    </span><br><span class="line">        return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;  </span><br><span class="line">      &#125;  </span><br><span class="line">        return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JSX特定属性：</strong></p>
<ul>
<li>可以通过使用引号，来将属性值指定为字符串字面量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用大括号，来在属性值中插入一个 JavaScript 表达式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;</span><br></pre></td></tr></table></figure>

<p>注：在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号</p>
<ul>
<li>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</li>
</ul>
<p><strong>第三章：组件&amp;Props</strong></p>
<p><strong>前言：组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。</strong></p>
<p><strong>props：代表属性</strong></p>
<p><strong>函数组件：</strong>接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Welcome(props) &#123;  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Class组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;  </span><br><span class="line">    render() &#123;    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个组件用等效</p>
<p><strong>渲染组件：</strong></p>
<ul>
<li>用户自定义的React组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</span><br></pre></td></tr></table></figure>

<p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Welcome(props) &#123;  </span><br><span class="line">    return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; </span><br><span class="line">&#125; </span><br><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; </span><br><span class="line">ReactDOM.render(  element,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>在以上例子中：</p>
<ol>
<li><p>我们调用 ReactDOM.render() 函数，并传入 作为参数。</p>
</li>
<li><p>React 调用 Welcome 组件，并将 {name: ‘Sara’} 作为 props 传入。</p>
</li>
<li><p>Welcome 组件将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Hello, Sara&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>元素作为返回值。</p>
</li>
<li><p>React DOM 将 DOM 高效地更新为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Hello, Sara&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>组合组件：</strong></p>
<p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。</p>
<p>例：多次渲染Welcome组件的App组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Welcome(props) &#123;  </span><br><span class="line">    return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; </span><br><span class="line">&#125; </span><br><span class="line">function App() &#123;  </span><br><span class="line">    return (    </span><br><span class="line">        &lt;div&gt;      </span><br><span class="line">            &lt;Welcome name=&quot;Sara&quot; /&gt;      </span><br><span class="line">            &lt;Welcome name=&quot;Cahal&quot; /&gt;      </span><br><span class="line">            &lt;Welcome name=&quot;Edite&quot; /&gt;      </span><br><span class="line">            //以上代码中，可以把Welcome看作一个类，name为这个类未赋值的属性      </span><br><span class="line">            //App组件可以看作是Welcome的具体化，Welcome可以看做是一个模板    </span><br><span class="line">        &lt;/div&gt;  ); </span><br><span class="line">&#125; </span><br><span class="line">ReactDOM.render(  &lt;App /&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>提取组件：</strong></p>
<p>源代码提取前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Comment(props) &#123;   </span><br><span class="line">     return (     </span><br><span class="line">         &lt;div className=&quot;Comment&quot;&gt;       </span><br><span class="line">             &lt;div className=&quot;UserInfo&quot;&gt;         </span><br><span class="line">                 &lt;img className=&quot;Avatar&quot; src=&#123;props.author.avatarUrl&#125;   alt=&#123;props.author.name&#125;/&gt;         </span><br><span class="line">                 &lt;div className=&quot;UserInfo-name&quot;&gt;           </span><br><span class="line">                     &#123;props.author.name&#125;         </span><br><span class="line">                 &lt;/div&gt;       </span><br><span class="line">             &lt;/div&gt;       </span><br><span class="line">             &lt;div className=&quot;Comment-text&quot;&gt;         </span><br><span class="line">                 &#123;props.text&#125;       </span><br><span class="line">             &lt;/div&gt;       </span><br><span class="line">             &lt;div className=&quot;Comment-date&quot;&gt;         </span><br><span class="line">                 &#123;formatDate(props.date)&#125;       </span><br><span class="line">             &lt;/div&gt;     </span><br><span class="line">         &lt;/div&gt;   ); &#125; </span><br><span class="line">const comment = &#123;   </span><br><span class="line">    date: new Date(),   </span><br><span class="line">    text: &#x27;I hope you enjoy learning React!&#x27;,   </span><br><span class="line">    author: &#123;     </span><br><span class="line">        name: &#x27;Hello Kitty&#x27;,     </span><br><span class="line">        avatarUrl: &#x27;https://placekitten.com/g/64/64&#x27;,   </span><br><span class="line">    &#125;, </span><br><span class="line">&#125;; </span><br><span class="line">ReactDOM.render(   </span><br><span class="line">    &lt;Comment     </span><br><span class="line">        date=&#123;comment.date&#125;     </span><br><span class="line">        text=&#123;comment.text&#125;     </span><br><span class="line">        author=&#123;comment.author&#125;   /&gt;,   </span><br><span class="line">    document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>提取后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function formatDate(date) &#123;   </span><br><span class="line">     return date.toLocaleDateString(); &#125; </span><br><span class="line">//头像组件嵌套在用户信息组件中，将头像组件单独提取出来，其中的各属性作为UserInfo </span><br><span class="line">//中重定义名为User的属性，逆向赋值子组件对象，层层嵌套 </span><br><span class="line">//头像组件，user未定义 </span><br><span class="line">function Avatar(props) &#123;   return (     &lt;img       className=&quot;Avatar&quot;       src=&#123;props.user.avatarUrl&#125;       alt=&#123;props.user.name&#125;     /&gt;   ); &#125; </span><br><span class="line">//用户信息组件，给上一层Avatar中User定义 </span><br><span class="line">function UserInfo(props) &#123;   return (     &lt;div className=&quot;UserInfo&quot;&gt;       &lt;Avatar user=&#123;props.user&#125; /&gt;       &lt;div className=&quot;UserInfo-name&quot;&gt;&#123;props.user.name&#125;&lt;/div&gt;     &lt;/div&gt;   ); &#125; </span><br><span class="line">//给UserInfo中的author定义 </span><br><span class="line">function Comment(props) &#123;   </span><br><span class="line">    return (     </span><br><span class="line">        &lt;div className=&quot;Comment&quot;&gt;       </span><br><span class="line">            &lt;UserInfo user=&#123;props.author&#125; /&gt;       </span><br><span class="line">            &lt;div className=&quot;Comment-text&quot;&gt;&#123;props.text&#125;&lt;/div&gt;       </span><br><span class="line">            &lt;div className=&quot;Comment-date&quot;&gt;         </span><br><span class="line">                &#123;formatDate(props.date)&#125;       </span><br><span class="line">            &lt;/div&gt;     </span><br><span class="line">        &lt;/div&gt;  </span><br><span class="line">    ); </span><br><span class="line">&#125;  </span><br><span class="line">const comment = &#123;   </span><br><span class="line">    date: new Date(),   </span><br><span class="line">    text: &#x27;I hope you enjoy learning React!&#x27;,   </span><br><span class="line">    author: &#123;     </span><br><span class="line">        name: &#x27;Hello Kitty&#x27;,     </span><br><span class="line">        avatarUrl: &#x27;https://placekitten.com/g/64/64&#x27;,   </span><br><span class="line">    &#125;, </span><br><span class="line">&#125;; </span><br><span class="line">ReactDOM.render(   </span><br><span class="line">    &lt;Comment     </span><br><span class="line">        date=&#123;comment.date&#125;     </span><br><span class="line">        text=&#123;comment.text&#125;     </span><br><span class="line">        author=&#123;comment.author&#125;   /&gt;,   </span><br><span class="line">    document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>注：建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。</p>
<p><strong>Props的只读性</strong></p>
<ul>
<li><strong>组件无论是使用*<em><strong>函数声明还是通过 class 声明</strong></em>*，都决不能修改自身的 props。</strong></li>
<li><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></li>
</ul>
<p><strong>第四章：State &amp; 生命周期</strong></p>
<p><img src="/images/post20121102.png" alt="react函数生命周期"></p>
<p><strong>State与Props的区别</strong></p>
<p>Props是组件对外的接口，State是组件对内的接口，</p>
<p>组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。根据对外接口props 和对内接口state，组件计算出对应界面的UI。</p>
<p><strong>主要区别：</strong></p>
<ul>
<li>State是可变的，是一组用于反映组件UI变化的状态集合；</li>
<li>Props对于使用它的组件来说，是只读的，要想修改Props，只能通过该组件的父组件修改。</li>
</ul>
<p>在组件状态上移的场景中，父组件正是通过子组件的Props, 传递给子组件其所需要的状态。</p>
<p>改变State的状态使用setState（）</p>
<p><strong>关键点：</strong></p>
<ul>
<li>当一个组件或数据的状态不是唯一不变的，那么既可以用State申明</li>
<li>State是自顶向下的，也就是说，state只能向下赋值</li>
<li>State和Props的更新是异步的，不能依赖上一个State给下一个State赋值</li>
<li>此外，State会合并更新，这是为了提高执行效率</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function FormattedDate(props) &#123;   </span><br><span class="line">    return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;; </span><br><span class="line">&#125;  </span><br><span class="line">class Clock extends React.Component &#123;   </span><br><span class="line">    constructor(props) &#123;     </span><br><span class="line">        super(props);     </span><br><span class="line">        this.state = &#123;date: new Date()&#125;;   </span><br><span class="line">    &#125; </span><br><span class="line">    //挂载   </span><br><span class="line"> componentDidMount() &#123;     </span><br><span class="line">     this.timerID = setInterval(       </span><br><span class="line">         () =&gt; this.tick(),       1000    </span><br><span class="line">     );   </span><br><span class="line"> &#125; </span><br><span class="line">    //卸载   </span><br><span class="line">    componentWillUnmount() &#123;     </span><br><span class="line">        clearInterval(this.timerID);   </span><br><span class="line">    &#125;    </span><br><span class="line">    tick() &#123;     </span><br><span class="line">        this.setState(&#123;       </span><br><span class="line">            date: new Date()     </span><br><span class="line">        &#125;);   </span><br><span class="line">    &#125;    </span><br><span class="line">    render() &#123;     </span><br><span class="line">        return (       </span><br><span class="line">            &lt;div&gt;         </span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;         </span><br><span class="line">                &lt;FormattedDate date=&#123;this.state.date&#125; /&gt;       </span><br><span class="line">            &lt;/div&gt;     );   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line">function App() &#123;   </span><br><span class="line">    return (     </span><br><span class="line">        &lt;div&gt;       </span><br><span class="line">            &lt;Clock /&gt;       </span><br><span class="line">            &lt;Clock /&gt;       </span><br><span class="line">            &lt;Clock /&gt;     </span><br><span class="line">        &lt;/div&gt;   </span><br><span class="line">    ); </span><br><span class="line">&#125;  </span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p><strong>生命周期：</strong></p>
<p>可通过挂载（mount）或卸载（umount）的方式来为组件添加生命周期</p>
<p><strong>第五章：事件处理</strong></p>
<ul>
<li>React事件命名采用小驼峰方式，及首字母小写第二个单词大写</li>
<li>使用大括号代替分号</li>
</ul>
<p>//传统的HTML</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;activateLasers()&quot;&gt;  Activate Lasers &lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>//在React中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;  Activate Lasers &lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。</p>
<p>例如，传统的 HTML 中阻止链接默认打开一个新页面，你可以这样写：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot; onclick=&quot;console.log(&#x27;The link was clicked.&#x27;); return false&quot;&gt;   </span><br><span class="line">    Click me </span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>在 React 中，可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ActionLink() &#123;  </span><br><span class="line">    function handleClick(e) &#123;    </span><br><span class="line">        e.preventDefault();</span><br><span class="line">        //e为event事件对象的合集    </span><br><span class="line">        console.log(&#x27;The link was clicked.&#x27;);  </span><br><span class="line">    &#125;   </span><br><span class="line">    return (    </span><br><span class="line">        &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt;      </span><br><span class="line">            Click me    </span><br><span class="line">        &lt;/a&gt;  ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第六章：条件渲染</strong></p>
<p><strong>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。</strong></p>
<p>以下是一个根据登录状态来显示不同的提示语的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//HTML部分依旧是一个id为root的div </span><br><span class="line">function UserGreeting(props)&#123;    </span><br><span class="line">    return &lt;h1&gt;Welcome Back!&lt;/h1&gt;; </span><br><span class="line">&#125; </span><br><span class="line">function GuestGreeting(props)&#123;    </span><br><span class="line">    return &lt;h1&gt;Please Sign In!&lt;/h1&gt;; </span><br><span class="line">&#125; </span><br><span class="line">function Greeting(props)&#123;    </span><br><span class="line">    const ifLogin=props.ifLogin;    </span><br><span class="line">    if(ifLogin)&#123;       </span><br><span class="line">        return &lt;UserGreeting /&gt;;    </span><br><span class="line">    &#125;    </span><br><span class="line">    return &lt;GuestGreeting /&gt;; </span><br><span class="line">&#125; ReactDOM.render(    </span><br><span class="line">    &lt;Greeting ifLogin=&#123;false&#125;/&gt;,   </span><br><span class="line">    document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>与运算符&amp;&amp;</strong></p>
<p>通过花括号包裹代码，可以在 JSX 中嵌入任何表达式。这也包括 JavaScript 中的逻辑与 (&amp;&amp;) 运算符。它可以很方便地进行元素的条件渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Mailbox(props) &#123;  </span><br><span class="line">    const unreadMessages = props.unreadMessages;  </span><br><span class="line">    return (    </span><br><span class="line">        &lt;div&gt;      </span><br><span class="line">            &lt;h1&gt;Hello!&lt;/h1&gt;      </span><br><span class="line">            &#123;unreadMessages.length &gt; 0 &amp;&amp;        </span><br><span class="line">                &lt;h2&gt;          </span><br><span class="line">                    You have &#123;unreadMessages.length&#125; unread messages.        </span><br><span class="line">                &lt;/h2&gt;      </span><br><span class="line">            &#125;    </span><br><span class="line">        &lt;/div&gt;  ); </span><br><span class="line">&#125; </span><br><span class="line">const messages = [&#x27;React&#x27;, &#x27;Re: React&#x27;, &#x27;Re:Re: React&#x27;]; </span><br><span class="line">ReactDOM.render(  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>因为在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。</p>
<p>因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p>
<p><strong>三目运算符</strong></p>
<p>另一种内联条件渲染的方式是JavaScript的 <strong>condition?true:false</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render() &#123;  </span><br><span class="line">    const isLoggedIn = this.state.isLoggedIn;  </span><br><span class="line">    return (  </span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            The user is &lt;b&gt;&#123;isLoggedIn ? &#x27;currently&#x27; : &#x27;not&#x27;&#125;&lt;/b&gt; logged in.    </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    ); &#125; </span><br><span class="line">//isLoggedIn ? &#x27;currently&#x27; : &#x27;not&#x27; 等同于如下 </span><br><span class="line">if(condition)&#123;    </span><br><span class="line">    return &#x27;currently&#x27;;</span><br><span class="line">&#125;    </span><br><span class="line">	return &#x27;not&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>阻止组件渲染</strong></p>
<p>在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。</p>
<p><strong>第七章：列表&amp;key</strong></p>
<p><strong>列表</strong></p>
<p>JavaScript转化列表实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明一个数组 </span><br><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">//数组逐一乘二放入numbers并将得到的新数组重新定义为</span><br><span class="line">doubled const doubled = numbers.map((number) =&gt; number * 2); </span><br><span class="line">//输出doubled </span><br><span class="line">console.log(doubled);</span><br></pre></td></tr></table></figure>

<p>将js变更的数据渲染到DOM中，使用JSX</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">const listItems = numbers.map((numbers) =&gt;  &lt;li&gt;&#123;numbers&#125;&lt;/li&gt; ); </span><br><span class="line">ReactDOM.render(  &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>当你创建一个元素时，必须包括一个特殊的 key 属性，故此以上代码会出现a key should be provided for list items警告，所以将其更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function NumberList(props) &#123;  </span><br><span class="line">	const numbers = props.numbers;  </span><br><span class="line">	const listItems = </span><br><span class="line">		numbers.map((number) =&gt;</span><br><span class="line">		&lt;li key=&#123;number.toString()&#125;&gt;      </span><br><span class="line">			&#123;number&#125;    </span><br><span class="line">		&lt;/li&gt;  </span><br><span class="line">    	);  </span><br><span class="line">	return (&lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;  ); </span><br><span class="line">    &#125; </span><br><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">ReactDOM.render(  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>key</strong></p>
<ul>
<li>帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">const listItems = numbers.map((number) =&gt;  </span><br><span class="line">	&lt;li key=&#123;number.toString()&#125;&gt;    </span><br><span class="line">		&#123;number&#125;  </span><br><span class="line">	&lt;/li&gt; );</span><br></pre></td></tr></table></figure>

<ul>
<li>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const todoItems = </span><br><span class="line">      todos.map((todo) =&gt;</span><br><span class="line">                            &lt;li key=&#123;todo.id&#125;&gt;    </span><br><span class="line">                                &#123;todo.text&#125;  </span><br><span class="line">                            &lt;/li&gt; );</span><br></pre></td></tr></table></figure>

<ul>
<li>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;  </span><br><span class="line">                            // Only do this if items have no stable IDs  </span><br><span class="line">                            &lt;li key=&#123;index&#125;&gt;    &#123;todo.text&#125;  &lt;/li&gt; </span><br><span class="line">                           );</span><br></pre></td></tr></table></figure>

<ul>
<li>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 Robin Pokorny 的深度解析使用索引作为 key 的负面影响 这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。</li>
</ul>
<p><strong>用 key 提取组件</strong></p>
<p>元素的 key 只有放在就近的数组上下文中才有意义。比方说，如果你提取 出一个 ListItem 组件，你应该把 key 保留在数组中的这个 元素上，而不是放在 ListItem 组件中的</p>
<p>元素上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ListItem(props) &#123;  </span><br><span class="line">    const value = props.value;  </span><br><span class="line">    return (    </span><br><span class="line">        // 错误！你不需要在这里指定 key：    </span><br><span class="line">        &lt;li key=&#123;value.toString()&#125;&gt;      </span><br><span class="line">            &#123;value&#125;    </span><br><span class="line">        &lt;/li&gt;  </span><br><span class="line">    ); </span><br><span class="line">&#125; </span><br><span class="line">function NumberList(props) &#123;  </span><br><span class="line">    const numbers = props.numbers;  </span><br><span class="line">    const listItems = numbers.map((number) =&gt;    </span><br><span class="line">                                  // 错误！元素的 key 应该在这里指定：    </span><br><span class="line">                                  &lt;ListItem value=&#123;number&#125; /&gt;  );  </span><br><span class="line">                                  return (    </span><br><span class="line">                                  &lt;ul&gt;      </span><br><span class="line">                                      &#123;listItems&#125;    </span><br><span class="line">                                  &lt;/ul&gt;  </span><br><span class="line">                                 ); </span><br><span class="line">&#125; </span><br><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">ReactDOM.render(  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>例子：正确的使用 key 的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ListItem(props) &#123;  </span><br><span class="line">    // 正确！这里不需要指定 key：  </span><br><span class="line">    return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;; </span><br><span class="line">&#125; </span><br><span class="line">function NumberList(props) &#123;  </span><br><span class="line">    const numbers = props.numbers;  </span><br><span class="line">    const listItems = numbers.map((number) =&gt;    </span><br><span class="line">                                  // 正确！key 应该在数组的上下文中被指定    </span><br><span class="line">                                  &lt;ListItem key=&#123;number.toString()&#125;  value=&#123;number&#125; /&gt;  );  </span><br><span class="line">                                  return (&lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt;  ); </span><br><span class="line">&#125; </span><br><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">ReactDOM.render(  </span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125; /&gt;,  </span><br><span class="line">    document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性</p>
<ul>
<li>key必须在兄弟节点唯一，如果全局中有多个不同的数据，key值可以不唯一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Blog(props) &#123;   </span><br><span class="line">    const sidebar = (     </span><br><span class="line">        &lt;ul&gt;       </span><br><span class="line">            &#123;props.posts.map((post) =&gt;</span><br><span class="line">                             &lt;li key=&#123;post.id&#125;&gt;           </span><br><span class="line">                                 &#123;post.title&#125;         </span><br><span class="line">                             &lt;/li&gt;       </span><br><span class="line">                            )&#125;     </span><br><span class="line">        &lt;/ul&gt;   </span><br><span class="line">    );   </span><br><span class="line">    const content = props.posts.map((post) =&gt;     </span><br><span class="line">                                    &lt;div key=&#123;post.id&#125;&gt;       </span><br><span class="line">                                        &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;       </span><br><span class="line">                                        &lt;p&gt;&#123;post.content&#125;&lt;/p&gt;     </span><br><span class="line">                                    &lt;/div&gt;   </span><br><span class="line">                                   );   </span><br><span class="line">                                    return (     </span><br><span class="line">                                    &lt;div&gt;       </span><br><span class="line">                                        &#123;sidebar&#125;       </span><br><span class="line">                                        &lt;hr /&gt;       </span><br><span class="line">                                        &#123;content&#125;     </span><br><span class="line">                                    &lt;/div&gt;   ); &#125;  </span><br><span class="line">const posts = [   </span><br><span class="line">    &#123;id: 1, title: &#x27;Hello World&#x27;, content: &#x27;Welcome to learning React!&#x27;&#125;,   </span><br><span class="line">    &#123;id: 2, title: &#x27;Installation&#x27;, content: &#x27;You can install React from npm.&#x27;&#125; </span><br><span class="line">]; </span><br><span class="line">ReactDOM.render(   &lt;Blog posts=&#123;posts&#125; /&gt;,   document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>key值只能传给React，不能传给当前组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const content=posts.map((post)=&gt;, </span><br><span class="line">                        &lt;Post key=&#123;post.id&#125;    </span><br><span class="line">                            id=&#123;post.id&#125;   </span><br><span class="line">                            titile=&#123;post.title&#125;/&gt;</span><br><span class="line">                       ) </span><br><span class="line">//以上组件中Post可以读出props.id但读不出props.key</span><br></pre></td></tr></table></figure>

<p><strong>在JSX中嵌入map（）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ListItem(props) &#123;  </span><br><span class="line">    return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;; </span><br><span class="line">&#125; </span><br><span class="line">function NumberList(props) &#123;  </span><br><span class="line">    const numbers = props.numbers;  </span><br><span class="line">    return (    </span><br><span class="line">        &lt;ul&gt;      </span><br><span class="line">            &#123;numbers.map((number) =&gt;        </span><br><span class="line">                         &lt;ListItem key=&#123;number.toString()&#125;                  </span><br><span class="line">                             value=&#123;number&#125; /&gt;      </span><br><span class="line">                        )&#125;    </span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    ); </span><br><span class="line">&#125; </span><br><span class="line">//JSX 允许在大括号中嵌入任何表达式， </span><br><span class="line">//所以我们可以内联 map() 返回的结果：</span><br><span class="line">const numbers = [1, 2, 3, 4, 5]; </span><br><span class="line">ReactDOM.render(  </span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125; /&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>第八章：表单</strong></p>
<p><strong>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这个纯 HTML 表单只接受一个名称 </span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;label&gt;    </span><br><span class="line">        名字:    </span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;  </span><br><span class="line">    &lt;/label&gt;  </span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;  </span><br><span class="line">    constructor(props) &#123;    </span><br><span class="line">        super(props);    </span><br><span class="line">        this.state = &#123;value: &#x27;&#x27;&#125;;    </span><br><span class="line">        this.handleChange = this.handleChange.bind(this);    </span><br><span class="line">        this.handleSubmit = this.handleSubmit.bind(this);  </span><br><span class="line">    &#125;   </span><br><span class="line">    handleChange(event) &#123;    </span><br><span class="line">        this.setState(&#123;value: event.target.value&#125;);  </span><br><span class="line">    &#125;   </span><br><span class="line">    handleSubmit(event) &#123;    </span><br><span class="line">        alert(&#x27;提交的名字: &#x27; + this.state.value);    </span><br><span class="line">        event.preventDefault();  &#125;   </span><br><span class="line">    render() &#123;    </span><br><span class="line">        return (</span><br><span class="line">        &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        </span><br><span class="line">                &lt;label&gt;          </span><br><span class="line">                    名字:          </span><br><span class="line">                    &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        </span><br><span class="line">                &lt;/label&gt;        </span><br><span class="line">                &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;      </span><br><span class="line">            &lt;/form&gt;    );  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于受控组件</strong></p>
<p>在HTML中&lt; input&gt;,&lt; select&gt;,&lt; textarea&gt;等元素通常自己维护state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使setState()来更新。我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<p><strong>状态提升</strong></p>
<p><strong>当多个子组件需要用到一个状态保持数据同步时，我们可以将他们的state放入他们共同的父组件中</strong></p>
<p>以下是一个华氏度和摄氏度同步变化的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const scaleNames = &#123;  c: &#x27;Celsius&#x27;,  f: &#x27;Fahrenheit&#x27; &#125;; </span><br><span class="line">//华氏度转摄氏度 </span><br><span class="line">function toCelsius(fahrenheit) &#123;  </span><br><span class="line">    return (fahrenheit - 32) * 5 / 9; </span><br><span class="line">&#125; </span><br><span class="line">//摄氏度转华氏度 </span><br><span class="line">function toFahrenheit(celsius) &#123;  </span><br><span class="line">    return (celsius * 9 / 5) + 32; </span><br><span class="line">&#125; </span><br><span class="line">function tryConvert(temperature, convert) &#123;  </span><br><span class="line">    //获取输入的温度  </span><br><span class="line">    const input = parseFloat(temperature);  </span><br><span class="line">    //输入无效字符返回空字符串  </span><br><span class="line">    if (Number.isNaN(input)) &#123;</span><br><span class="line">        return &#x27;&#x27;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //调用转化方法同步数据  </span><br><span class="line">    const output = convert(input);  </span><br><span class="line">    //四舍五入取后三位小数  </span><br><span class="line">    const rounded = Math.round(output * 1000) / 1000;  </span><br><span class="line">    return rounded.toString(); &#125; </span><br><span class="line">//提示文字切换方法 </span><br><span class="line">function BoilingVerdict(props) &#123;  </span><br><span class="line">    if (props.celsius &gt;= 100) &#123;    </span><br><span class="line">        return &lt;p&gt;The water would boil.&lt;/p&gt;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return &lt;p&gt;The water would not boil.&lt;/p&gt;; </span><br><span class="line">&#125; </span><br><span class="line">//温度输入的方法 </span><br><span class="line">class TemperatureInput extends React.Component &#123;  </span><br><span class="line">    constructor(props) &#123;    </span><br><span class="line">        super(props);    </span><br><span class="line">        this.handleChange = this.handleChange.bind(this); </span><br><span class="line">    &#125;   </span><br><span class="line">    handleChange(e) &#123;    </span><br><span class="line">        this.props.onTemperatureChange(e.target.value);</span><br><span class="line">    &#125;   </span><br><span class="line">    render() &#123;    </span><br><span class="line">        const temperature = this.props.temperature;    </span><br><span class="line">        const scale = this.props.scale;   </span><br><span class="line">        return (     </span><br><span class="line">            &lt;fieldset&gt;    </span><br><span class="line">                &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;        </span><br><span class="line">                &lt;input value=&#123;temperature&#125;            </span><br><span class="line">                    onChange=&#123;this.handleChange&#125; /&gt;  </span><br><span class="line">            &lt;/fieldset&gt;    );  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">class Calculator extends React.Component &#123;  </span><br><span class="line">    constructor(props) &#123;  </span><br><span class="line">        super(props);   </span><br><span class="line">        this.handleCelsiusChange = this.handleCelsiusChange.bind(this);    				this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);    		 this.state = &#123;temperature: &#x27;&#x27;, scale: &#x27;c&#x27;&#125;; </span><br><span class="line">    &#125;   </span><br><span class="line">    handleCelsiusChange(temperature) &#123; </span><br><span class="line">        this.setState(&#123;scale: &#x27;c&#x27;, temperature&#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">    handleFahrenheitChange(temperature) &#123;    </span><br><span class="line">        this.setState(&#123;scale: &#x27;f&#x27;, temperature&#125;); </span><br><span class="line">    &#125; </span><br><span class="line">    render() &#123;  </span><br><span class="line">        const scale = this.state.scale;   </span><br><span class="line">        const temperature = this.state.temperature;  </span><br><span class="line">        const celsius = scale === &#x27;f&#x27; ? tryConvert(temperature, toCelsius) : temperature;    </span><br><span class="line">        const fahrenheit = scale === &#x27;c&#x27; ? tryConvert(temperature, toFahrenheit) : temperature;   </span><br><span class="line">        return (     </span><br><span class="line">            &lt;div&gt;   </span><br><span class="line">                &lt;TemperatureInput     </span><br><span class="line">                    scale=&quot;c&quot;      </span><br><span class="line">                    temperature=&#123;celsius&#125;       </span><br><span class="line">                    onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt;       </span><br><span class="line">                &lt;TemperatureInput  </span><br><span class="line">                    scale=&quot;f&quot;       </span><br><span class="line">                    temperature=&#123;fahrenheit&#125;     </span><br><span class="line">                    onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt;        </span><br><span class="line">                &lt;BoilingVerdict      </span><br><span class="line">                    celsius=&#123;parseFloat(celsius)&#125; /&gt;  </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">ReactDOM.render( </span><br><span class="line">    &lt;Calculator /&gt;,</span><br><span class="line">    document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>组合VS继承</strong></p>
<p><strong>有些组件无法提前知晓它们子组件的具体内容。在 Sidebar（侧边栏）和 Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。</strong></p>
<p><strong>建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中。使任意组件可以通过JSX嵌套将任意组件传给chilren。</strong></p>
<p>我的理解是，在父组件未知要具体包含哪种类型的子组件时，可以用prop.chilren来代替，数据流向下在下一级中再已确定的组件填充进去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function FancyBorder(props) &#123;  </span><br><span class="line">    return (    </span><br><span class="line">        &lt;div className=&#123;&#x27;FancyBorder FancyBorder-&#x27; + props.color&#125;&gt;      </span><br><span class="line">            &#123;props.children&#125;   </span><br><span class="line">        &lt;/div&gt;  );</span><br><span class="line">&#125; </span><br><span class="line">function WelcomeDialog() &#123; </span><br><span class="line">    return (    </span><br><span class="line">        &lt;FancyBorder color=&quot;blue&quot;&gt;     </span><br><span class="line">            &lt;h1 className=&quot;Dialog-title&quot;&gt;    </span><br><span class="line">                Welcome    </span><br><span class="line">            &lt;/h1&gt;    </span><br><span class="line">            &lt;p className=&quot;Dialog-message&quot;&gt;  </span><br><span class="line">                Thank you for visiting our spacecraft! </span><br><span class="line">            &lt;/p&gt;   </span><br><span class="line">        &lt;/FancyBorder&gt;  ); </span><br><span class="line">&#125; </span><br><span class="line">ReactDOM.render(  &lt;WelcomeDialog /&gt;,  document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p><strong>一个层层传递组件的实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function FancyBorder(props) &#123;   </span><br><span class="line">    return (       </span><br><span class="line">        //父组件    </span><br><span class="line">        &lt;div className=&#123;&#x27;FancyBorder FancyBorder-&#x27; + props.color&#125;&gt;   </span><br><span class="line">            //一级组件声明     </span><br><span class="line">            &#123;props.children&#125;   </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;  </span><br><span class="line">function Dialog(props) &#123; </span><br><span class="line">    return (       </span><br><span class="line">        //一级组件 </span><br><span class="line">        &lt;FancyBorder color=&quot;blue&quot;&gt;  </span><br><span class="line">            &lt;h1 className=&quot;Dialog-title&quot;&gt;   </span><br><span class="line">                &#123;props.title&#125;     </span><br><span class="line">            &lt;/h1&gt;     </span><br><span class="line">            &lt;p className=&quot;Dialog-message&quot;&gt;  </span><br><span class="line">                &#123;props.message&#125; </span><br><span class="line">            &lt;/p&gt;    </span><br><span class="line">            //二级组件声明    </span><br><span class="line">            &#123;props.children&#125;     </span><br><span class="line">        &lt;/FancyBorder&gt;   );</span><br><span class="line">&#125;  </span><br><span class="line">class SignUpDialog extends React.Component &#123; </span><br><span class="line">    constructor(props) &#123;  </span><br><span class="line">        super(props);   </span><br><span class="line">        this.handleChange = this.handleChange.bind(this); </span><br><span class="line">        this.handleSignUp = this.handleSignUp.bind(this);  </span><br><span class="line">        //状态绑定login字符串    </span><br><span class="line">        this.state = &#123;login: &#x27;&#x27;&#125;;   </span><br><span class="line">    &#125;    </span><br><span class="line">    render() &#123;     </span><br><span class="line">        return (      </span><br><span class="line">            &lt;Dialog title=&quot;Mars Exploration Program&quot;    </span><br><span class="line">                message=&quot;How should we refer to you?&quot;&gt;   </span><br><span class="line">                &lt;input value=&#123;this.state.login&#125;     </span><br><span class="line">                    onChange=&#123;this.handleChange&#125; /&gt; </span><br><span class="line">                &lt;button onClick=&#123;this.handleSignUp&#125;&gt; </span><br><span class="line">                    Sign Me Up!     </span><br><span class="line">                &lt;/button&gt;    </span><br><span class="line">            &lt;/Dialog&gt;    </span><br><span class="line">        );   </span><br><span class="line">    &#125;    </span><br><span class="line">    handleChange(e) &#123; </span><br><span class="line">        this.setState(&#123;login: e.target.value&#125;);  </span><br><span class="line">    &#125;   </span><br><span class="line">    handleSignUp() &#123; </span><br><span class="line">        alert(`Welcome aboard, $&#123;this.state.login&#125;!`); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line">ReactDOM.render(   &lt;SignUpDialog /&gt;,   document.getElementById(&#x27;root&#x27;) );</span><br></pre></td></tr></table></figure>

<p>Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p>
<p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而<strong>无需</strong>通过 extend <strong>继承</strong>它们。</p>
<p><strong>知识点补充</strong></p>
<ol>
<li><p>构造函数里为什么要绑定点击函数？</p>
<p>以Counter组件为例，我们的构造函数有这样如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.onClickIncrementButton = this.onClickIncrementButton.bind(this);</span><br><span class="line">this.onClickDecrementButton = this.onClickDecrementButton.bind(this);</span><br></pre></td></tr></table></figure>

<p>这两句语句的作用，就是通过bind方法上当前示例中行的onClickIncrementButton和onClickDecrementButton函数被调用时，this始终是指向当前组件</p>
</li>
</ol>
]]></content>
  </entry>
</search>
